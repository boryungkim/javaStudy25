desc emp;  --emp 테이블 구조보기
select * from emp; -- emp 테이블 내용보기

desc dept;  --dept 테이블 구조보기
select * from dept; --dept 테이블 내용보기

desc bonus; -- bonus 테이블 구조보기
select * from bonus; --bonus 테이블 내용보기

desc salgrade; --salgrade 테이블 구조보기
select * from salgrade; --salgrade 테이블 내용보기

SELECT EMPNO, ENAME, DEPTNO FROM EMP; -- 대소문자 가능

select deptno from emp;

select distinct Deptno from emp; -- distinct 중복 제거

select distinct job, deptno from emp; -- distinct 중복 제거 (여러 열)

select all job, deptno from emp; -- ALL 중복 제거 없이

select ename, sal, sal*12+comm, comm from emp; --연산식 사용가능

select ename, sal, sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal+sal,comm from emp;

select ename, sal, sal*12+comm as annsal, comm from emp; --별칭 지정 (as)

select * from emp order by sal; -- 오름차순이 기본값 마지막에 (asc) 생략됨

select * from emp order by sal desc; -- 내림차순 설정

select * from emp order by deptno asc, sal desc; -- 부서번호(오름차순), 급여(내림차순)
-- 앞에서부터 1순위로 설정됨 -> 부서번호 먼저 오름차순 정리, 다음으로 급여 내림차순 정리

select * from emp where deptno = 30;
-- select  조회할 열 from 조회할 테이블  where  조건식

select * from emp where deptno = 30 and job = 'SALESMAN';
-- AND 문자열 데이터는 무조건 '' 안에 대문자를 사용해야 함

select * from emp where empno = 7499 and deptno = 30;

select * from emp where deptno = 30 or job = 'CLERK';
-- OR 연산자 FALSE FALSE 일 때에만 FALSE값을 가짐

SELECT * FROM EMP WHERE DEPTNO = 20 OR JOB = 'SALESMAN';
-- 부서 번호가 20 이거나(OR) 직업이 세일즈맨인 사람

SELECT * FROM EMP WHERE SAL * 12 = 36000;

SELECT * FROM EMP WHERE SAL >= 3000;

SELECT * FROM EMP WHERE SAL >= 2500 AND JOB = 'ANALYST';

SELECT * FROM EMP WHERE ENAME >= 'F';
--문자열 F 뒷쪽 출력

SELECT * FROM EMP WHERE ENAME <= 'FORZ';

SELECT * FROM EMP WHERE SAL != 3000;
SELECT * FROM EMP WHERE SAL <> 3000;
SELECT * FROM EMP WHERE SAL ^= 3000;
-- 같지 않다는 의미로 사용할 수 있는 세가지 방식 (!=, <> , ^=) -> 등가 비교 연산자 사용

SELECT * FROM EMP WHERE NOT SAL = 3000;
-- 같지 않다는 의미로 사용 (NOT) -> 논리 부정 연산자

SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
--OR 사용하여 여러 조건 만족 데이터 출력
SELECT * FROM EMP WHERE JOB IN ('MANAGER', 'SALESMAN', 'CLERK');
--IN 사용하여 간소화
SELECT * FROM EMP WHERE JOB != 'MANAGER' AND JOB <> 'SALESMAN' AND JOB ^= 'CLERK';
--AND 와 등가 비교 연산자 사용
SELECT * FROM EMP WHERE JOB NOT IN  ( 'MANAGER' , 'SALESMAN', 'CLERK');
-- 논리 부정 연산자 사용하여 간소화

SELECT * FROM EMP WHERE DEPTNO IN(10,20);

SELECT * FROM EMP WHERE SAL >=2000 AND SAL<= 3000;
-- 비교 연산자와 AND 연산자 사용
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;
SELECT * FROM EMP WHERE ENAME LIKE 'S%';
-- ENAME 열값이 S로 시작하는 데이터를 조회
SELECT * FROM EMP WHERE ENAME LIKE '_L%';
-- ENAME 두번째 글자가 L인 데이터 조회
SELECT * FROM EMP WHERE ENAME LIKE '%AM%';
-- ENAME에 AM이 포함된 데이터 조회 (순서상관X, 단 반드시 연속된 문자열-> 이 경우는 AM이어야 함)
SELECT * FROM EMP WHERE ENAME NOT LIKE '%AM%';
-- ENAME 에 AM이 포함되지 않은 데이터 조회
SELECT * FROM SOME_TABLE WHERE SOME_COLUMN LIKE 'A\_A%' ESCAPE '\';
--헷갈린다
--SELECT * FROM EMP WHERE COMM = NULL;
SELECT * FROM EMP WHERE COMM IS NULL;
-- NULL 여부를 살펴보기 위해서는 IS NULL 사용해야 함
SELECT * FROM EMP WHERE COMM IS NOT NULL;
--SELECT * FROM EMP WHERE SAL > NULL AND COMM IS NULL;
--SELECT * FROM EMP WHERE SAL > NULL OR COMM IS NULL;

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20;
-- 집합 연산자 -> 열개수, 자료형이 일치해야 함

--SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
--UNION SELECT EMPNO, ENAME, SAL FROM EMP WHERE EDPTNO = 20;

--SELECT EMPNO, ENAME, SAL, DEPTNP FROM EMP WHERE DEPTNO = 10 
--UNION SELECT ENAME, EMPNO, DEPTNO, SAL FROM EMP WEHRE DEPTNO = 20;

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION SELECT SAL,JOB, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20;
-- UNION -> 출력할 열개수와 자료형이 같으면 집합 연산자 사용 가능

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
-- UNION ALL -> 중복 데이터까지 모두 출력

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
MINUS SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
--ㅡMINUS -> 차집합 

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
INTERSECT SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
-- INTERSECT -> 교집합 : 같은 값의 데이터만 출력됨

SELECT * FROM EMP WHERE ENAME LIKE '%S';
-- ENAME S로 끝나는 DATA 출력

SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP 
WHERE JOB = 'SALESMAN';

SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO IN (10,20) AND SAL > 2000;
-- 집합 연산자 사용 X
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10 AND SAL > 2000
UNION SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20 AND SAL > 2000;
-- 집합 연산자 UNION 사용

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO FROM EMP WHERE 
SAL BETWEEN 2000 AND 3000;
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO FROM EMP WHERE 
SAL >= 2000 AND SAL <= 3000;

SELECT ENAME,EMPNO,SAL FROM EMP WHERE SAL NOT BETWEEN 1000 AND 2000
INTERSECT SELECT ENAME,EMPNO,SAL FROM EMP WHERE ENAME LIKE '%E%' AND DEPTNO = 30;

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO FROM EMP WHERE COMM 
IS NULL AND JOB != 'PRESIDENT' AND JOB IN ('MANAGER', 'CLERK') 
AND ENAME NOT LIKE '_L%';

SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME) FROM EMP;
SELECT * FROM EMP WHERE UPPER (ENAME) = UPPER('scott');




--조인

--select * from emp, dept order by empno;
select * from emp, dept where emp.deptno = dept.deptno order by empno;
-- 열이름 비교하는 조건식으로 조인
select * from emp E, dept D where E.deptno = D.deptno order by empno;
-- 테이블의 열 이름에 별칭 지정
select empno, d.dname from emp e, dept d where e.deptno = d.deptno order by empno;

--테이블의 열 이름이 같을 때 : 구분을 반드시 해주어야 함 아니면 오류남
--select empno, ename, deptno, dname, loc from emp e, dept d where e.DEPTNO = d.DEPTNO;
select e.empno, e.ename, d.deptno, d.dname, d.loc from emp e, dept d 
where e.DEPTNO = d.DEPTNO order by d.deptno, e.EMPNO;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D,DNAME, D.LOC FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND SAL >= 3000;
-- 조건식 추가 사용하여 출력 범위 설정

SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND E.SAL <=2500 AND E.EMPNO <= 9999 ORDER BY E.EMPNO;

SELECT * FROM EMP E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
-- 조건식 BETWEEN A AND B

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MRG_EMPNO, E2.ENAME AS MRG_ENAME
FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2 WHERE E1.MGR = E2.EMPNO(+) ORDER BY E1.EMPNO;
-- LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2 WHERE E1.MGR(+) = E2.EMPNO ORDER BY E1.EMPNO;
-- RIGHT OUTER JOIN

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO,
D.DNAME, D.LOC FROM EMP E NATURAL JOIN DEPT D ORDER BY DEPTNO, E.EMPNO;
--NATURAL JOIN

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO,
D.DNAME, D.LOC FROM EMP E JOIN DEPT D USING (DEPTNO) WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO;
--JOIN ~ USING (조인에 사용한 기준열)

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO,
D.DNAME, D.LOC FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO) WHERE SAL <= 3000
ORDER BY E.DEPTNO, EMPNO;
-- JOIN ~ ON (조인 조건식)

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO;
-- LETF OUTER JOIN (SQL)

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO;
-- RIGHTH OUTER JOIN (SQL)

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO) ORDER BY E1.EMPNO;
--FULL OUTER JOIN (SQL)

SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME,
D.LOC FROM EMP E JOIN DEPT D USING (DEPTNO) WHERE E.SAL>=3000 AND E.MGR IS NOT NULL
ORDER BY DEPTNO, E.EMPNO;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO AND E.SAL > 2000 ORDER BY D.DEPTNO, D.DNAME;

SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM EMP E NATURAL JOIN DEPT D
WHERE E.SAL > 2000 ORDER BY DEPTNO, D.DNAME;

--전에 챕터 배운 다음에
--SELECT D.DEPTNO, D.DNAME, AVG(SAL)  E.CNT FROM DEPT D, EMP E
--ORDER BY D.DEPTNO;

--Q3
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO(+) ORDER BY D.DEPTNO;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM DEPT D
LEFT OUTER JOIN EMP E ON(D.DEPTNO = E.DEPTNO) ORDER BY D.DEPTNO;

--Q4 ---다시 봐야 함 답 수정해야 함
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR,E.SAL,E.DEPTNO, S.LOSAL, S.HISAL,
S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME FROM EMP E, DEPT D, SALGRADE S,
EMP E2 WHERE E.DEPTNO(+) = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL
AND E.MGR = E2.EMPNO(+) ORDER BY D.DEPTNO, E.EMPNO;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR,E.SAL,E.DEPTNO, S.LOSAL, S.HISAL,
S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME

-------------------------------------------------------CH 8 조인
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');

-------------------------------------------------------CH 9 서브 쿼리
DROP TABLE DEPT_TEMP;

CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC) VALUES (50, 'DATABASE', 
'SEOUL'); 
SELECT * FROM DEPT_TEMP;
--데이터 추가하기  (자료형, 데이터 개수 맞춰줘야 함)

INSERT INTO DEPT_TEMP 
VALUES (60, 'NETWORK' ,'BUSAN'); 
SELECT * FROM DEPT_TEMP;
-- 열지정 없이 데이터 추가하기

INSERT INTO DEPT_TEMP (DEPTNO,DNAME, LOC) 
VALUES (70, 'WEB', NULL);
SELECT * FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC) 
VALUES (80, 'MOBILE','');
SELECT * FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO, LOC) VALUES (90, 'INCHEON');
SELECT * FROM DEPT_TEMP; 

CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1 <> 1;
SELECT * FROM EMP_TEMP;
-- 열 구조만 같은 테이블 복사하기

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동', 'PRESIDENT', NULL, '2001/01/01', 5000, 1000, 10);
SELECT * FROM EMP_TEMP;
--공백도 문자 수에 포함됨

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (1111, '성춘향', 'MANAGER', 9999, '2001-01-05', 4000, NULL, 20);
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2111, '이순신', 'MANAGER', 9999, TO_DATE('07/01/2001','DD/MM/YYYY'), 4000, NULL, 20);
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (3111, '심청이', 'MANAGER', 9999, SYSDATE, 4000, NULL, 30);
SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
FROM EMP E, SALGRADE S WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE =1;
SELECT * FROM EMP_TEMP;
--서브 쿼리를 사용할 경우 -> VALUES 절은 사용하지 않는다, 추가되는 테이블 열과 서브쿼리 열개수 일치,
-- 추가되는 테이블 자료형과 서브쿼리 자료형 일치

CREATE TABLE DEPT_TEMP2 AS SELECT * FROM DEPT;
SELECT *FROM DEPT_TEMP2;

UPDATE DEPT_TEMP2 SET LOC = 'SEOUL';
SELECT * FROM DEPT_TEMP2;
--LOC 열이 모두 SEOUL로 변경됨

ROLLBACK;

UPDATE DEPT_TEMP2 SET DNAME= 'DATABASE', LOC = 'SEOUL' WHERE DEPTNO = 40;
SELECT * FROM DEPT_TEMP2;

UPDATE EMP_TEMP SET COMM = 50 WHERE SAL <= 2500;
SELECT * FROM EMP_TEMP;

UPDATE DEPT_TEMP2 SET(DNAME, LOC) = (SELECT DNAME, LOC FROM DEPT WHERE
DEPTNO = 40) WHERE DEPTNO = 40; 
SELECT * FROM DEPT_TEMP2;
-- 서브 쿼리 학습 후에 다시보기

CREATE TABLE EMP_TEMP2 AS SELECT * FROM EMP;
SELECT * FROM EMP_TEMP2;

DELETE FROM EMP_TEMP2 WHERE JOB = 'MANAGER'; 
SELECT * FROM EMP_TEMP2;

DELETE FROM EMP_TEMP2;
SELECT * FROM EMP_TEMP2;
--전체 삭제
----------------------------------------CH 10 데이터 조작어
CREATE TABLE DEPT_TCL AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TCL;

INSERT INTO DEPT_TCL VALUES (50,'DATABASE', 'SEOUL');SQL
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';
SELECT * FROM DEPT_TCL;
ROLLBACK;

SELECT * FROM DEPT_TCL;
DELETE FROM DEPT_TCL WHERE DEPTNO = 40;
SELECT * FROM DEPT_TCL;
COMMIT;
SELECT * FROM DEPT_TCL;
UPDATE DEPT_TCL SET LOC = 'SEOUL' WHERE DEPTNO = 30;
SELECT * FROM DEPT_TCL;
COMMIT;

SELECT * FROM DEPT_TCL;

UPDATE DEPT_TCL SET LOC = 'SEOUL'; DELETE FROM DEPT_TCL;

CREATE TABLE EMP_DDL(
EMPNO NUMBER(4),
ENAME VARCHAR2(10),
JOB VARCHAR2(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7,2),
COMM NUMBER(7,2),
DEPTNO NUMBER(2)
);
DESC EMP_DDL;

CREATE TABLE DEPT_DDL AS SELECT * FROM DEPT;
DESC DEPT_DDL;
SELECT * FROM DEPT_DDL;
--기존 테이블 열 구조와 데이터 복사하여 새 테이블 생성

CREATE TABLE EMP_DDL_30 AS SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP_DDL_30;
-- 기존 테이블 일부 데이터만 복사 새 테이블 생성

CREATE TABLE EMPDEPT_DDL AS SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE,
E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE 1 <> 1;
SELECT * FROM EMPDEPT_DDL;
--FALSE값 억지로 만들어서 열구조만 복사하기

CREATE TABLE EMP_ALTER AS SELECT * FROM EMP;
SELECT * FROM EMP_ALTER;
--EMP테이블 복사하여 EMP_ALTER만들기

ALTER TABLE EMP_ALTER ADD HP VARCHAR(20);
SELECT * FROM EMP_ALTER;
--ALTER로 수정 ADD로 추가

ALTER TABLE EMP_ALTER RENAME COLUMN HP TO TEL;
SELECT * FROM EMP_ALTER;
--RENAME COLUMN A TO B

ALTER TABLE EMP_ALTER MODIFY EMPNO NUMBER(5);
DESC EMP_ALTER;
--ALTER -> EMPNO 길이 번경 (VARCHAR: 문자열, NUMBER : 숫자)

ALTER TABLE EMP_ALTER DROP COLUMN TEL;
SELECT * FROM EMP_ALTER;
--특정 열 삭제 DROP (구조를 삭제할 경우 -> DROP/ 데이터를 삭제할 경우 -> DELETE)

RENAME EMP_ALTER TO EMP_RENAME;
DESC EMP_ALTER;
SELECT * FROM EMP_RENAME;
--테이블 이름 변경 RENAME A TO B

TRUNCATE TABLE EMP_RENAME;
SELECT*FROM EMP_RENAME;
--전체 삭제 -> TRUNCATE :정의어이기 때문에 ROLLBACK이 되지 않음, DELETE와 다른점

DROP TABLE EMP_RENAME;
DESC EMP_RENAME;
--DROP : 정의어이기 때문에 ROLLBACK 되지 않음

---------------------------------------------------------CH12데이터 정의어

SELECT * FROM DICT;
SELECT * FROM DICTIONARY;

SELECT TABLE_NAME FROM USER_TABLES;
--SCOTT 계정이 가지고 있는 객체 정보 살펴보기

SELECT OWNER, TABLE_NAME FROM ALL_TABLES;
SELECT * FROM DBA_TABLES;

SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;

CREATE INDEX IDX_EMP_SAL ON EMP(SAL);
SELECT * FROM USER_IND_COLUMNS;

DROP INDEX IDX_EMP_SAL;
SELECT * FROM USER_IND_COLUMNS;

CREATE VIEW VW_EMP20 AS (SELECT EMPNO, ENAME, JOB, DEPTNO FROM EMP WHERE DEPTNO = 20);
SELECT * FROM USER_VIEWS;

SELECT * FROM VW_EMP20;
DROP VIEW VW_EMP20;

SELECT ROWNUM, E.* FROM EMP E;
SELECT ROWNUM, E.* FROM EMP E ORDER BY SAL DESC;
SELECT ROWNUM, E.* FROM(SELECT * FROM EMP E ORDER BY SAL DESC) E; 
--인라인 뷰 (서브쿼리 사용)
WITH E AS(SELECT * FROM EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E;
-- WITH 절 사용 , 서브쿼리
SELECT ROWNUM, E.* FROM (SELECT*FROM EMP E ORDER BY SAL DESC) E WHERE ROWNUM <= 3;
WITH E AS (SELECT * FROM EMP ORDER BY SAL DESC) SELECT ROWNUM, E.* FROM E 
WHERE ROWNUM <= 3;
--WITH 절 사용 인라인 뷰

CREATE TABLE DEPT_SEQUENCE AS SELECT * FROM DEPT WHERE 1<>1;
SELECT * FROM DEPT_SEQUENCE; 

DROP SEQUENCE SEQ_DEPT_SEQUENCE;
CREATE SEQUENCE SEQ_DEPT_SEQUENCE INCREMENT BY 10 START WITH 10 MAXVALUE 90
MINVALUE 0 NOCYCLE CACHE 2;
SELECT * FROM USER_SEQUENCES;

INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL,'DATABASE','SEOUL');
SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

SELECT SEQ_DEPT_SEQUENCE.CURRVAL FROM DUAL;

INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL,'DATABASE', 'SEOUL');
SELECT * FROM DEPT_SEQUENCE ORDER BY DEPTNO;

ALTER SEQUENCE SEQ_DEPT_SEQUENCE INCREMENT BY 3 MAXVALUE 99 CYCLE;
SELECT * FROM USER_SEQUENCES;

INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
--VALUES (SEQ_DEPT

--------------------------------------CH13 객체종료
CREATE TABLE TABLE_NOTNULL(
LOGIN_ID VARCHAR2(20) NOT NULL,
LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL VARCHAR2(20)
);
DESC TABLE_NOTNULL;

--INSERT INTO TABLE_NOTNULL (LOGIN_ID, LOGIN_PWD, TEL)
--VALUES ('TEST_ID_01', null, '010-1234-5678');

INSERT INTO TABLE_NOTNULL (LOGIN_ID,LOGIN_PWD) VALUES ('TEST_ID_01', '1234');
SELECT * FROM TABLE_NOTNULL;

UPDATE TABLE_NOTNULL SET LOGIN_PWD = NULL WHERE LOGIN_ID = 'TEST_ID_01';

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

CREATE TABLE TABLE_NOTNULL2(LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLNN2_LGNPW_NN NOT NULL, TEL VARCHAR2(20));
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

--ALTER TABLE TABLE_NOTNULL MODIFY(TEL NOT NULL);

UPDATE TABLE_NOTNULL SET TEL='010-1234-5678' WHERE LOGIN_ID = 'TEST_ID_01';
SELECT * FROM TABLE_NOTNULL;

ALTER TABLE TABLE_NOTNULL MODIFY(TEL NOT NULL);
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS; 
-- TEL 에 NOT NULL 제약 조건 추가

ALTER TABLE TABLE_NOTNULL2 MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;

DESC TABLE_NOTNULL2;
ALTER TABLE TABLE_NOTNULL2 RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS;
--제약조건 이름 변경하기 RENAME CONSTRAINT A TO B

ALTER TABLE TABLE_NOTNULL2 DROP CONSTRAINT TBLNN2_TEL_NN;
DESC TABLE_NOTNULL2;
--제약 조건 삭제하기

DROP TABLE TABLE_UNIQUE;

CREATE TABLE TABLE_UNIQUE(LOGIN_ID VARCHAR2(20) UNIQUE, LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL VARCHAR2(20));
DESC TABLE_UNIQUE;

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_UNIQUE';
--테이블 생성하면서 제약 조건 UNIQUE 지정

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_01', 'PWD01',
'010-1234-5678'); 
SELECT * FROM TABLE_UNIQUE;
--TABLE_UNIQUE 에 데이터 입력하기

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES ('TEST_ID_02', 'PWD01',
'010-1234-5678'); 
SELECT * FROM TABLE_UNIQUE;

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, 'PWD01', '010-2345-6789');
SELECT * FROM TABLE_UNIQUE;
--UNIQUE 제약 지정된 열에 NULL 값 입력


UPDATE TABLE_UNIQUE SET LOGIN_ID = 'TEST_ID_01' WHERE LOGIN_ID IS NULL;

CREATE TABLE TABLE_UNIQUE2(LOGIN_ID VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNID_UNQ UNIQUE,
LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLUNQ2_LGNPW_NN NOT NULL, TEL VARCHAR(20));
-- 테이블 생성할 때 UNIQUE, NOT NULL 조건 생성

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';

ALTER TABLE TABLE_UNIQUE MODIFY(TEL UNIQUE);
UPDATE TABLE_UNIQUE SET TEL=NULL;
SELECT * FROM TABLE_UNIQUE;
-- TEL 값 NULL로 변경 -> 이미 중복된 값 있기 때문에 지워줌 (UNIQUE 제약 추가하기 위해)

DROP TABLE TABLE_UNIQUE2;
ALTER TABLE TABLE_UNIQUE2 MODIFY(TEL CONSTRAINT TBLUNQ_TEL_UNQ UNIQUE);
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS 
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
--생성 테이블에서 제약 조건 이름 지정

ALTER TABLE TABLE_UNIQUE2 RENAME CONSTRAINT TBLUNQ_TEL_UNQ TO TBLUNQ2_TEL_UNQ;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
--이미 만들어진 UNIQUE 제약 조건 이름 수정

ALTER TABLE TABLE_UNIQUE2 DROP CONSTRAINT TBLUNQ2_TEL_UNQ;
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_UNIQUE%';
--제약 조건 삭제

CREATE TABLE TABLE_PK(LOGIN_ID VARCHAR2(20) PRIMARY KEY, LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL VARCHAR2(20)); 
DESC TABLE_PK;
-- 테이블 생성하며 PRIMARY KEY 지정

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_PK%';

SELECT INDEX_NAME, TABLE_OWNER, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME
LIKE 'TABLE_PK%';
-- 생성한 PRIMARY KEY 통해 자동생성된 INDEX 확인

CREATE TABLE TABLE_PK2(LOGIN_ID VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLPK2_LGNPW_NN NOT NULL, TEL VARCHAR2(20));
DESC TABLE_PK2;
--테이블 생성하며 제약조건 이름 직접 지정

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');
SELECT * FROM TABLE_PK;

INSERT INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL) VALUES(NULL, 'PWD02', '010-2345-6789');
INSERT INTO TABLE_PK(LOGIN_PWD, TEL) VALUES('PWD02', '010-2345-6789');
-- NULL 값은 PRIMARY KEY 제약이 걸려있을 경우 추가할 수 없다

SELECT OWNER,CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_OWNER, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS WHERE TABLE_NAME IN ('EMP','DEPT');
--EMP 테이블과 DEPT 테이블 제약조건 살펴보기

INSERT INTO EMP(EMPNO


